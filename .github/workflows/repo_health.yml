# ============================================================================
# Copyright (C) 2025 Moko Consulting <hello@mokoconsulting.tech>
#
# This file is part of a Moko Consulting project.
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# FILE INFORMATION
# DEFGROUP: GitHub.Workflow
# INGROUP: MokoStandards.Validation
# REPO: https://github.com/mokoconsulting-tech/MokoStandards
# PATH: /.github/workflows/repo_health.yml
# VERSION: 03.05.00
# BRIEF: Enforces repository guardrails by validating release configuration, scripts governance, tooling availability, and core repository health artifacts.
# NOTE: Field is user-managed.
# ============================================================================

name: Repo Health

concurrency:
  group: repo-health-${{ github.repository }}-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

on:
  workflow_dispatch:
    inputs:
      profile:
        description: Which configuration profile to validate. release checks SFTP variables used by release pipeline. scripts checks baseline script prerequisites. repo runs repository health only. all runs release, scripts, and repo health.
        required: true
        default: all
        type: choice
        options:
          - all
          - release
          - scripts
          - repo
  pull_request:
    paths:
      - .github/workflows/**
      - scripts/**
      - docs/**
      - dev/**
  push:
    branches:
      - main
    paths:
      - .github/workflows/**
      - scripts/**
      - docs/**
      - dev/**

permissions:
  contents: read

env:
  # Global policy variables baked into workflow
  ALLOWED_SFTP_PROTOCOLS: sftp
  RELEASE_REQUIRED_VARS: FTP_HOST,FTP_USER,FTP_PATH
  RELEASE_OPTIONAL_VARS: FTP_KEY,FTP_PASSWORD,FTP_PROTOCOL,FTP_PORT,FTP_PATH_SUFFIX

  SCRIPTS_RECOMMENDED_DIRS: scripts/fix,scripts/lib,scripts/release,scripts/run,scripts/validate
  SCRIPTS_ALLOWED_DIRS: scripts,scripts/fix,scripts/lib,scripts/release,scripts/run,scripts/validate

  REPO_REQUIRED_FILES: README.md,LICENSE,CHANGELOG.md,CONTRIBUTING.md,CODE_OF_CONDUCT.md,docs/docs-index.md
  REPO_OPTIONAL_FILES: SECURITY.md,GOVERNANCE.md,.editorconfig,.gitattributes,.gitignore
  REPO_REQUIRED_PATHS: .github/workflows,scripts,docs,dev
  REPO_DISALLOWED_DIRS: src
  REPO_DISALLOWED_FILES: TODO.md,todo.md

  # Operational toggles
  SFTP_VERBOSE: "false"

jobs:
  access_check:
    name: Access control
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read

    outputs:
      allowed: ${{ steps.perm.outputs.allowed }}
      permission: ${{ steps.perm.outputs.permission }}

    steps:
      - name: Check actor permission (admin only)
        id: perm
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const res = await github.rest.repos.getCollaboratorPermissionLevel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              username: context.actor
            });

            const permission = (res?.data?.permission || 'unknown').toLowerCase();
            const allowed = permission === 'admin';

            core.setOutput('permission', permission);
            core.setOutput('allowed', allowed ? 'true' : 'false');

            const lines = [];
            lines.push('### Access control');
            lines.push('');
            lines.push(`Actor: ${context.actor}`);
            lines.push(`Permission: ${permission}`);
            lines.push(`Allowed: ${allowed}`);
            lines.push('');
            lines.push('Policy: This workflow runs only for users with admin permission on the repository.');

            await core.summary.addRaw(lines.join('\n')).write();

      - name: Deny execution when not permitted
        if: ${{ steps.perm.outputs.allowed != 'true' }}
        run: |
          set -euo pipefail
          printf '%s\n' 'ERROR: Access denied. Admin permission required.' >> "${GITHUB_STEP_SUMMARY}"
          exit 1

  release_config:
    name: Release configuration
    needs: access_check
    if: ${{ needs.access_check.outputs.allowed == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Guardrails release secrets and vars
        env:
          PROFILE_RAW: ${{ github.event.inputs.profile }}
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USER }}
          FTP_KEY: ${{ secrets.FTP_KEY }}
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
          FTP_PATH: ${{ secrets.FTP_PATH }}
          FTP_PROTOCOL: ${{ secrets.FTP_PROTOCOL }}
          FTP_PORT: ${{ secrets.FTP_PORT }}
          FTP_PATH_SUFFIX: ${{ vars.FTP_PATH_SUFFIX }}
        run: |
          set -euo pipefail

          profile="${PROFILE_RAW:-all}"
          case "${profile}" in
            all|release|scripts|repo) ;;
            *)
              printf '%s\n' "ERROR: Unknown profile: ${profile}" >> "${GITHUB_STEP_SUMMARY}"
              exit 1
              ;;
          esac

          if [ "${profile}" = 'scripts' ] || [ "${profile}" = 'repo' ]; then
            printf '%s\n' "Profile ${profile} selected. Skipping release configuration checks." >> "${GITHUB_STEP_SUMMARY}"
            exit 0
          fi

          IFS=',' read -r -a required <<< "${RELEASE_REQUIRED_VARS}"
          IFS=',' read -r -a optional <<< "${RELEASE_OPTIONAL_VARS}"
          IFS=',' read -r -a allowed_proto <<< "${ALLOWED_SFTP_PROTOCOLS}"

          missing=()
          missing_optional=()

          for k in "${required[@]}"; do
            v="${!k:-}"
            [ -z "${v}" ] && missing+=("${k}")
          done

          for k in "${optional[@]}"; do
            v="${!k:-}"
            [ -z "${v}" ] && missing_optional+=("${k}")
          done

          proto="${FTP_PROTOCOL:-sftp}"

          if [ -n "${FTP_PROTOCOL:-}" ]; then
            ok=false
            for ap in "${allowed_proto[@]}"; do
              [ "${proto}" = "${ap}" ] && ok=true
            done
            [ "${ok}" = false ] && missing+=("FTP_PROTOCOL_INVALID")
          fi

          if [ "${#missing_optional[@]}" -gt 0 ]; then
            {
              printf '%s\n' '### Missing optional release configuration'
              for m in "${missing_optional[@]}"; do printf '%s\n' "- ${m}"; done
              printf '\n'
            } >> "${GITHUB_STEP_SUMMARY}"
          fi

          if [ "${#missing[@]}" -gt 0 ]; then
            {
              printf '%s\n' '### Missing required release configuration'
              for m in "${missing[@]}"; do printf '%s\n' "- ${m}"; done
              printf '%s\n' 'ERROR: Guardrails failed. Missing required release configuration.'
            } >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          {
            printf '%s\n' '### Guardrails release configuration'
            printf '%s\n' 'All required release variables present.'
            printf '\n'
          } >> "${GITHUB_STEP_SUMMARY}"

      - name: Guardrails SFTP connectivity
        env:
          PROFILE_RAW: ${{ github.event.inputs.profile }}
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USER }}
          FTP_KEY: ${{ secrets.FTP_KEY }}
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
          FTP_PORT: ${{ secrets.FTP_PORT }}
        run: |
          set -euo pipefail

          profile="${PROFILE_RAW:-all}"
          case "${profile}" in
            all|release|scripts|repo) ;;
            *)
              printf '%s\n' "ERROR: Unknown profile: ${profile}" >> "${GITHUB_STEP_SUMMARY}"
              exit 1
              ;;
          esac

          if [ "${profile}" = 'scripts' ] || [ "${profile}" = 'repo' ]; then
            printf '%s\n' "Profile ${profile} selected. Skipping SFTP connectivity check." >> "${GITHUB_STEP_SUMMARY}"
            exit 0
          fi

          mkdir -p "$HOME/.ssh"

          key_file="$HOME/.ssh/ci_sftp_key"
          use_key=false

          if [ -n "${FTP_KEY:-}" ]; then
            printf '%s\n' "${FTP_KEY}" > "${key_file}"
            chmod 600 "${key_file}"
            use_key=true

            if [ -n "${FTP_PASSWORD:-}" ]; then
              first_line="$(head -n 1 "${key_file}" || true)"
              if printf '%s\n' "${first_line}" | grep -q '^PuTTY-User-Key-File-'; then
                printf '%s\n' 'ERROR: FTP_KEY appears to be a PuTTY PPK. Provide an OpenSSH private key.' >> "${GITHUB_STEP_SUMMARY}"
                exit 1
              fi
              ssh-keygen -p -P "${FTP_PASSWORD}" -N '' -f "${key_file}" >/dev/null
            fi
          fi

          port="${FTP_PORT:-22}"

          sftp_verbose="${SFTP_VERBOSE:-false}"
          sftp_v_opt=()
          if [ "${sftp_verbose}" = 'true' ]; then
            sftp_v_opt=(-vv)
          fi

          {
            printf '%s\n' '### SFTP connectivity test'
            printf '%s\n' 'Attempting non-destructive SFTP session'
            printf '\n'
          } >> "${GITHUB_STEP_SUMMARY}"

          set +e
          if [ "${use_key}" = true ]; then
            printf 'pwd\nbye\n' | sftp "${sftp_v_opt[@]}" -oBatchMode=yes -oStrictHostKeyChecking=no -P "${port}" -i "${key_file}" "${FTP_USER}@${FTP_HOST}" >/tmp/sftp_check.log 2>&1
          elif [ -n "${FTP_PASSWORD:-}" ]; then
            command -v sshpass >/dev/null 2>&1 || (sudo apt-get update -qq && sudo apt-get install -y sshpass >/dev/null)
            printf 'pwd\nbye\n' | sshpass -p "${FTP_PASSWORD}" sftp "${sftp_v_opt[@]}" -oBatchMode=no -oStrictHostKeyChecking=no -P "${port}" "${FTP_USER}@${FTP_HOST}" >/tmp/sftp_check.log 2>&1
          else
            printf '%s\n' 'ERROR: No FTP_KEY or FTP_PASSWORD provided for SFTP authentication.' >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi
          sftp_rc=$?
          set -e

          printf '%s\n' '### SFTP connectivity result' >> "${GITHUB_STEP_SUMMARY}"
          if [ "${sftp_rc}" -eq 0 ]; then
            printf '%s\n' 'Status: SUCCESS' >> "${GITHUB_STEP_SUMMARY}"
            exit 0
          fi

          {
            printf '%s\n' "Status: FAILED (exit code ${sftp_rc})"
            printf '\n'
            printf '%s\n' 'Last SFTP output'
            tail -n 40 /tmp/sftp_check.log || true
          } >> "${GITHUB_STEP_SUMMARY}"
          exit 1

  scripts_governance:
    name: Scripts governance
    needs: access_check
    if: ${{ needs.access_check.outputs.allowed == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Scripts folder checks
        env:
          PROFILE_RAW: ${{ github.event.inputs.profile }}
        run: |
          set -euo pipefail

          profile="${PROFILE_RAW:-all}"
          case "${profile}" in
            all|release|scripts|repo) ;;
            *)
              printf '%s\n' "ERROR: Unknown profile: ${profile}" >> "${GITHUB_STEP_SUMMARY}"
              exit 1
              ;;
          esac

          if [ "${profile}" = 'release' ] || [ "${profile}" = 'repo' ]; then
            printf '%s\n' "Profile ${profile} selected. Skipping scripts governance." >> "${GITHUB_STEP_SUMMARY}"
            exit 0
          fi

          if [ ! -d scripts ]; then
            {
              printf '%s\n' '### Scripts governance'
              printf '%s\n' 'Warning: scripts/ directory not present. No scripts governance enforced.'
              printf '\n'
            } >> "${GITHUB_STEP_SUMMARY}"
            exit 0
          fi

          IFS=',' read -r -a recommended_dirs <<< "${SCRIPTS_RECOMMENDED_DIRS}"
          IFS=',' read -r -a allowed_dirs <<< "${SCRIPTS_ALLOWED_DIRS}"

          missing_dirs=()
          unapproved_dirs=()

          for d in "${recommended_dirs[@]}"; do
            [ ! -d "${d}" ] && missing_dirs+=("${d}/")
          done

          while IFS= read -r d; do
            allowed=false
            for a in "${allowed_dirs[@]}"; do
              [ "${d}" = "${a}" ] && allowed=true
            done
            [ "${allowed}" = false ] && unapproved_dirs+=("${d}/")
          done < <(find scripts -maxdepth 1 -mindepth 1 -type d 2>/dev/null | sed 's#^\./##')

          {
            printf '%s\n' '### Scripts governance'
            if [ "${#missing_dirs[@]}" -gt 0 ]; then
              printf '%s\n' 'Missing recommended script directories:'
              for m in "${missing_dirs[@]}"; do printf '%s\n' "- ${m}"; done
              printf '\n'
            fi

            if [ "${#unapproved_dirs[@]}" -gt 0 ]; then
              printf '%s\n' 'Unapproved script directories detected:'
              for m in "${unapproved_dirs[@]}"; do printf '%s\n' "- ${m}"; done
              printf '\n'
            fi

            printf '%s\n' '| Area | Status | Notes |'
            printf '%s\n' '|------|--------|-------|'
            if [ "${#missing_dirs[@]}" -gt 0 ]; then
              printf '%s\n' '| Recommended directories | Warning | Missing recommended subfolders |'
            else
              printf '%s\n' '| Recommended directories | OK | All recommended subfolders present |'
            fi
            if [ "${#unapproved_dirs[@]}" -gt 0 ]; then
              printf '%s\n' '| Directory policy | Warning | Unapproved directories detected |'
            else
              printf '%s\n' '| Directory policy | OK | No unapproved directories |'
            fi
            printf '%s\n' '| Enforcement mode | Advisory | scripts folder is optional |'
            printf '\n'
            printf '%s\n' 'Scripts governance completed in advisory mode.'
          } >> "${GITHUB_STEP_SUMMARY}"

  repo_health:
    name: Repository health
    needs: access_check
    if: ${{ needs.access_check.outputs.allowed == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Repository health checks
        env:
          PROFILE_RAW: ${{ github.event.inputs.profile }}
        run: |
          set -euo pipefail

          profile="${PROFILE_RAW:-all}"
          case "${profile}" in
            all|release|scripts|repo) ;;
            *)
              printf '%s\n' "ERROR: Unknown profile: ${profile}" >> "${GITHUB_STEP_SUMMARY}"
              exit 1
              ;;
          esac

          if [ "${profile}" = 'release' ] || [ "${profile}" = 'scripts' ]; then
            printf '%s\n' "Profile ${profile} selected. Skipping repository health checks." >> "${GITHUB_STEP_SUMMARY}"
            exit 0
          fi

          IFS=',' read -r -a required_files <<< "${REPO_REQUIRED_FILES}"
          IFS=',' read -r -a optional_files <<< "${REPO_OPTIONAL_FILES}"
          IFS=',' read -r -a required_paths <<< "${REPO_REQUIRED_PATHS}"
          IFS=',' read -r -a disallowed_dirs <<< "${REPO_DISALLOWED_DIRS}"
          IFS=',' read -r -a disallowed_files <<< "${REPO_DISALLOWED_FILES}"

          missing_required=()
          missing_optional=()

          for f in "${required_files[@]}"; do
            [ ! -f "${f}" ] && missing_required+=("${f}")
          done

          for f in "${optional_files[@]}"; do
            [ ! -f "${f}" ] && missing_optional+=("${f}")
          done

          for p in "${required_paths[@]}"; do
            [ ! -d "${p}" ] && missing_required+=("${p}/")
          done

          for d in "${disallowed_dirs[@]}"; do
            if [ -d "${d}" ]; then
              missing_required+=("${d}/ (disallowed)")
            fi
          done

          for f in "${disallowed_files[@]}"; do
            if [ -f "${f}" ]; then
              missing_required+=("${f} (disallowed)")
            fi
          done

          git fetch origin --prune

          dev_paths=()
          dev_branches=()

          while IFS= read -r b; do
            name="${b#origin/}"
            if [ "${name}" = 'dev' ]; then
              dev_branches+=("${name}")
            else
              dev_paths+=("${name}")
            fi
          done < <(git branch -r --list 'origin/dev*' | sed 's/^ *//')

          if [ "${#dev_paths[@]}" -eq 0 ]; then
            missing_required+=("dev/* branch (e.g. dev/01.00.00)")
          fi

          if [ "${#dev_branches[@]}" -gt 0 ]; then
            missing_required+=("invalid branch dev (must be dev/<version>)")
          fi

          content_warnings=()

          if [ -f 'CHANGELOG.md' ] && ! grep -Eq '^# Changelog' CHANGELOG.md; then
            content_warnings+=("CHANGELOG.md missing '# Changelog' header")
          fi

          if [ -f 'LICENSE' ] && ! grep -qiE 'GNU GENERAL PUBLIC LICENSE|GPL' LICENSE; then
            content_warnings+=("LICENSE does not look like a GPL text")
          fi

          if [ -f 'README.md' ] && ! grep -qiE 'moko|Moko' README.md; then
            content_warnings+=("README.md missing expected brand keyword")
          fi

          export PROFILE_RAW="${profile}"
          export MISSING_REQUIRED="$(printf '%s\n' "${missing_required[@]:-}")"
          export MISSING_OPTIONAL="$(printf '%s\n' "${missing_optional[@]:-}")"
          export CONTENT_WARNINGS="$(printf '%s\n' "${content_warnings[@]:-}")"

          report_json="$(python3 - <<'PY'
import json
import os

profile = os.environ.get('PROFILE_RAW') or 'all'

missing_required = os.environ.get('MISSING_REQUIRED', '').splitlines() if os.environ.get('MISSING_REQUIRED') else []
missing_optional = os.environ.get('MISSING_OPTIONAL', '').splitlines() if os.environ.get('MISSING_OPTIONAL') else []
content_warnings = os.environ.get('CONTENT_WARNINGS', '').splitlines() if os.environ.get('CONTENT_WARNINGS') else []

out = {
  'profile': profile,
  'missing_required': [x for x in missing_required if x],
  'missing_optional': [x for x in missing_optional if x],
  'content_warnings': [x for x in content_warnings if x],
}

print(json.dumps(out, indent=2))
PY
)"

          {
            printf '%s\n' '### Guardrails repository health'
            printf '\n'
            printf '%s\n' '### Guardrails report (JSON)'
            printf '%s\n' '```json'
            printf '%s\n' "${report_json}"
            printf '%s\n' '```'
            printf '\n'
          } >> "${GITHUB_STEP_SUMMARY}"

          if [ "${#missing_required[@]}" -gt 0 ]; then
            {
              printf '%s\n' '### Missing required repo artifacts'
              for m in "${missing_required[@]}"; do printf '%s\n' "- ${m}"; done
              printf '%s\n' 'ERROR: Guardrails failed. Missing required repository artifacts.'
            } >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          if [ "${#missing_optional[@]}" -gt 0 ]; then
            {
              printf '%s\n' '### Missing optional repo artifacts'
              for m in "${missing_optional[@]}"; do printf '%s\n' "- ${m}"; done
              printf '\n'
            } >> "${GITHUB_STEP_SUMMARY}"
          fi

          if [ "${#content_warnings[@]}" -gt 0 ]; then
            {
              printf '%s\n' '### Repo content warnings'
              for m in "${content_warnings[@]}"; do printf '%s\n' "- ${m}"; done
              printf '\n'
            } >> "${GITHUB_STEP_SUMMARY}"
          fi

          printf '%s\n' 'Repository health guardrails passed.' >> "${GITHUB_STEP_SUMMARY}"

# EOF
