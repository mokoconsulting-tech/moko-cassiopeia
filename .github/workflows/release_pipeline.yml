#
# Copyright (C) 2025 Moko Consulting <hello@mokoconsulting.tech>
#
# This file is part of a Moko Consulting project.
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# FILE INFORMATION
# DEFGROUP: GitHub.Workflow
# INGROUP: MokoStandards.Release
# REPO: https://github.com/mokoconsulting-tech/MokoStandards
# PATH: /.github/workflows/release_pipeline.yml
# VERSION: 01.02.00
# BRIEF: Enterprise release pipeline enforcing dev to rc to version to main. Creates prerelease when rc is created. Creates full release when version is created and promotes to main while retaining the version branch.
# NOTE: Controls: strict branch gating, mandatory source branch deletion after promotion, key-only SFTP with verbose logs, ZIP-only distribution with overwrite, no checksum generation.
#
name: Release Pipeline (dev to rc to version to main)

on:
  workflow_dispatch:
    inputs:
      release_classification:
        description: "Manual override for classification. auto follows branch policy; rc forces prerelease behavior; stable forces full release behavior."
        required: true
        default: auto
        type: choice
        options:
          - auto
          - rc
          - stable
  release:
    types:
      - created
      - prereleased
      - published

concurrency:
  group: release-pipeline-${{ github.ref_name }}
  cancel-in-progress: false

defaults:
  run:
    shell: bash

permissions:
  contents: read

jobs:
  guard:
    name: 00 Guard and derive promotion metadata
    runs-on: ubuntu-latest

    outputs:
      version: ${{ steps.meta.outputs.version }}
      source_branch: ${{ steps.meta.outputs.source_branch }}
      source_prefix: ${{ steps.meta.outputs.source_prefix }}
      target_branch: ${{ steps.meta.outputs.target_branch }}
      promoted_branch: ${{ steps.meta.outputs.promoted_branch }}
      today_utc: ${{ steps.meta.outputs.today_utc }}
      channel: ${{ steps.meta.outputs.channel }}
      release_mode: ${{ steps.meta.outputs.release_mode }}
      override: ${{ steps.meta.outputs.override }}

    steps:
      - name: Validate trigger and extract metadata
        id: meta
        env:
          RELEASE_CLASSIFICATION: ${{ github.event.inputs.release_classification }}
          RELEASE_PRERELEASE: ${{ github.event.release.prerelease }}
        run: |
          set -euo pipefail

          EVENT_NAME="${GITHUB_EVENT_NAME}"
          REF_NAME="${GITHUB_REF_NAME}"

          VERSION=""
          SOURCE_BRANCH=""
          SOURCE_PREFIX=""
          TARGET_BRANCH=""
          PROMOTED_BRANCH=""
          CHANNEL=""
          RELEASE_MODE="none"

          OVERRIDE="${RELEASE_CLASSIFICATION:-auto}"
          if [ -z "${OVERRIDE}" ]; then
            OVERRIDE="auto"
          fi

          if [ "${EVENT_NAME}" = "workflow_dispatch" ]; then
            echo "${REF_NAME}" | grep -E '^(dev|rc)/[0-9]+[.][0-9]+[.][0-9]+$'

            SOURCE_BRANCH="${REF_NAME}"
            SOURCE_PREFIX="${REF_NAME%%/*}"
            VERSION="${REF_NAME#*/}"

            if [ "${SOURCE_PREFIX}" = "dev" ]; then
              # dev -> rc
              TARGET_BRANCH="rc/${VERSION}"
              PROMOTED_BRANCH="rc/${VERSION}"
              CHANNEL="rc"
              RELEASE_MODE="prerelease"
            else
              # rc -> version
              TARGET_BRANCH="version/${VERSION}"
              PROMOTED_BRANCH="version/${VERSION}"
              CHANNEL="stable"
              RELEASE_MODE="stable"
            fi

            # Manual override: classification only. Promotion path does not change.
            if [ "${OVERRIDE}" = "rc" ]; then
              CHANNEL="rc"
              RELEASE_MODE="prerelease"
            elif [ "${OVERRIDE}" = "stable" ]; then
              CHANNEL="stable"
              RELEASE_MODE="stable"
            else
              OVERRIDE="auto"
            fi

          elif [ "${EVENT_NAME}" = "release" ]; then
            TAG_NAME="${REF_NAME}"
            VERSION="${TAG_NAME#v}"
            echo "${VERSION}" | grep -E '^[0-9]+[.][0-9]+[.][0-9]+$'

            if [ "${RELEASE_PRERELEASE:-false}" = "true" ]; then
              CHANNEL="rc"
              RELEASE_MODE="prerelease"
            else
              CHANNEL="stable"
              RELEASE_MODE="stable"
            fi

            OVERRIDE="auto"

          else
            echo "ERROR: Unsupported trigger ${EVENT_NAME}" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          TODAY_UTC="$(date -u +%Y-%m-%d)"

          echo "version=${VERSION}" >> "${GITHUB_OUTPUT}"
          echo "source_branch=${SOURCE_BRANCH}" >> "${GITHUB_OUTPUT}"
          echo "source_prefix=${SOURCE_PREFIX}" >> "${GITHUB_OUTPUT}"
          echo "target_branch=${TARGET_BRANCH}" >> "${GITHUB_OUTPUT}"
          echo "promoted_branch=${PROMOTED_BRANCH}" >> "${GITHUB_OUTPUT}"
          echo "today_utc=${TODAY_UTC}" >> "${GITHUB_OUTPUT}"
          echo "channel=${CHANNEL}" >> "${GITHUB_OUTPUT}"
          echo "release_mode=${RELEASE_MODE}" >> "${GITHUB_OUTPUT}"
          echo "override=${OVERRIDE}" >> "${GITHUB_OUTPUT}"

          {
            echo "### Guard report"
            echo "```json"
            echo "{"
            echo "  \"event\": \"${EVENT_NAME}\","
            echo "  \"ref\": \"${REF_NAME}\","
            echo "  \"version\": \"${VERSION}\","
            echo "  \"source_branch\": \"${SOURCE_BRANCH}\","
            echo "  \"target_branch\": \"${TARGET_BRANCH}\","
            echo "  \"promoted_branch\": \"${PROMOTED_BRANCH}\","
            echo "  \"channel\": \"${CHANNEL}\","
            echo "  \"release_mode\": \"${RELEASE_MODE}\","
            echo "  \"override\": \"${OVERRIDE}\","
            echo "  \"today_utc\": \"${TODAY_UTC}\""
            echo "}"
            echo "```"
          } >> "${GITHUB_STEP_SUMMARY}"

  promote_branch:
    name: 01 Promote branch and delete source
    runs-on: ubuntu-latest
    needs: guard

    if: ${{ github.event_name == 'workflow_dispatch' }}

    permissions:
      contents: write

    steps:
      - name: Checkout source branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.guard.outputs.source_branch }}
          fetch-depth: 0

      - name: Configure Git identity
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global --add safe.directory "${GITHUB_WORKSPACE}"

      - name: Enforce promotion preconditions
        run: |
          set -euo pipefail

          SRC="${{ needs.guard.outputs.source_branch }}"
          DST="${{ needs.guard.outputs.target_branch }}"

          git fetch origin --prune

          if [ -z "${SRC}" ] || [ -z "${DST}" ]; then
            echo "ERROR: guard did not emit SRC or DST" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          if ! git show-ref --verify --quiet "refs/remotes/origin/${SRC}"; then
            echo "ERROR: origin/${SRC} not found" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          if git show-ref --verify --quiet "refs/remotes/origin/${DST}"; then
            echo "ERROR: origin/${DST} already exists" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

      - name: Promote and delete source
        run: |
          set -euo pipefail

          SRC="${{ needs.guard.outputs.source_branch }}"
          DST="${{ needs.guard.outputs.target_branch }}"

          git checkout -B "${DST}" "origin/${SRC}"
          git push origin "${DST}"
          git push origin --delete "${SRC}"

          {
            echo "### Promotion report"
            echo "```json"
            echo "{"
            echo "  \"promoted\": \"${SRC} -> ${DST}\","
            echo "  \"deleted\": \"${SRC}\""
            echo "}"
            echo "```"
          } >> "${GITHUB_STEP_SUMMARY}"

  normalize_dates:
    name: 02 Normalize dates on promoted branch
    runs-on: ubuntu-latest
    needs:
      - guard
      - promote_branch

    if: ${{ github.event_name == 'workflow_dispatch' }}

    permissions:
      contents: write

    steps:
      - name: Checkout promoted branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.guard.outputs.promoted_branch }}
          fetch-depth: 0

      - name: Configure Git identity
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global --add safe.directory "${GITHUB_WORKSPACE}"

      - name: Validate repo prerequisites
        run: |
          set -euo pipefail
          test -d src || (echo "ERROR: src directory missing" && exit 1)
          test -f CHANGELOG.md || (echo "ERROR: CHANGELOG.md missing" && exit 1)

          VERSION="${{ needs.guard.outputs.version }}"

          if ! grep -F "## [${VERSION}] " CHANGELOG.md >/dev/null; then
            echo "ERROR: CHANGELOG.md missing heading for version [${VERSION}]" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

      - name: Normalize dates using repository script only
        run: |
          set -euo pipefail

          TODAY="${{ needs.guard.outputs.today_utc }}"
          VERSION="${{ needs.guard.outputs.version }}"

          {
            echo "### Date normalization (repo script only)"
            echo "```json"
            echo "{\"today_utc\":\"${TODAY}\",\"version\":\"${VERSION}\"}"
            echo "```"
          } >> "${GITHUB_STEP_SUMMARY}"

          # Enterprise control: repo-provided date normalization is mandatory.
          CANDIDATES=(
            "scripts/update_dates.sh"
            "scripts/release/update_dates.sh"
            "scripts/release/update_dates"
          )

          SCRIPT=""
          for c in "${CANDIDATES[@]}"; do
            if [ -f "${c}" ]; then
              SCRIPT="${c}"
              break
            fi
          done

          if [ -z "${SCRIPT}" ]; then
            FOUND="$(find . -maxdepth 3 -type f \( -name 'update_dates.sh' -o -name 'update-dates.sh' \) 2>/dev/null | head -n 5 || true)"
            {
              echo "ERROR: Date normalization script not found in approved locations."
              echo "Approved locations:"
              printf '%s\n' "${CANDIDATES[@]}"
              echo "Discovered candidates (first 5):"
              echo "${FOUND:-<none>}"
              echo "Required action: add scripts/update_dates.sh (or scripts/release/update_dates.sh) to the repo."
            } >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          echo "Using date script: ${SCRIPT}" >> "${GITHUB_STEP_SUMMARY}"

          chmod +x "${SCRIPT}"
          "${SCRIPT}" "${TODAY}" "${VERSION}" >> "${GITHUB_STEP_SUMMARY}"

  build_and_release:
    name: 03 Build ZIP, upload to SFTP, create GitHub release
    runs-on: ubuntu-latest
    needs:
      - guard
      - normalize_dates

    if: ${{ github.event_name == 'workflow_dispatch' }}

    permissions:
      contents: write
      id-token: write
      attestations: write

    steps:
      - name: Checkout promoted branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.guard.outputs.promoted_branch }}
          fetch-depth: 0

      - name: Configure Git identity
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global --add safe.directory "${GITHUB_WORKSPACE}"

      - name: Build Joomla compliant ZIP
        id: build
        run: |
          set -euo pipefail

          VERSION="${{ needs.guard.outputs.version }}"
          REPO="${{ github.event.repository.name }}"
          CHANNEL="${{ needs.guard.outputs.channel }}"

          test -d src || (echo "ERROR: src directory missing" && exit 1)

          mkdir -p dist

          ROOT="src"
          TOP_DIRS="$(find src -mindepth 1 -maxdepth 1 -type d | wc -l | tr -d ' ')"
          if [ "${TOP_DIRS}" = "1" ]; then
            ROOT="$(find src -mindepth 1 -maxdepth 1 -type d -print -quit)"
          fi

          MANIFEST=""
          if [ -f "${ROOT}/templateDetails.xml" ]; then
            MANIFEST="${ROOT}/templateDetails.xml"
          elif [ -f "src/templates/templateDetails.xml" ]; then
            MANIFEST="src/templates/templateDetails.xml"
          elif find "src/templates" -mindepth 2 -maxdepth 2 -name "templateDetails.xml" -type f | head -n 1 | grep -q .; then
            MANIFEST="$(find "src/templates" -mindepth 2 -maxdepth 2 -name "templateDetails.xml" -type f | head -n 1)"
          else
            CANDIDATE="$(find "${ROOT}" -maxdepth 1 -type f -name "*.xml" | head -n 1 || true)"
            if [ -n "${CANDIDATE}" ]; then
              MANIFEST="${CANDIDATE}"
            fi
          fi

          if [ -z "${MANIFEST}" ]; then
            echo "ERROR: No Joomla manifest XML found" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          EXT_TYPE="$(grep -o 'type=\"[^\"]*\"' "${MANIFEST}" | head -n 1 | cut -d '"' -f2)"
          if [ -z "${EXT_TYPE}" ]; then
            EXT_TYPE="unknown"
          fi

          MANIFEST_DIR="$(dirname "${MANIFEST}")"
          if [ "${EXT_TYPE}" = "template" ] && [ "${MANIFEST_DIR}" != "${ROOT}" ]; then
            ROOT="${MANIFEST_DIR}"
          fi

          ZIP="${REPO}-${VERSION}-${CHANNEL}.zip"

          (cd "${ROOT}" && zip -r -X "../dist/${ZIP}" . \
            -x "**/.git/**" \
            -x "**/.github/**" \
            -x "**/.DS_Store" \
            -x "**/__MACOSX/**")

          echo "zip_name=${ZIP}" >> "${GITHUB_OUTPUT}"
          echo "root=${ROOT}" >> "${GITHUB_OUTPUT}"
          echo "manifest=${MANIFEST}" >> "${GITHUB_OUTPUT}"
          echo "ext_type=${EXT_TYPE}" >> "${GITHUB_OUTPUT}"

      - name: Upload ZIP to SFTP (key-only, overwrite, verbose)
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USER }}
          FTP_KEY: ${{ secrets.FTP_KEY }}
          FTP_PATH: ${{ secrets.FTP_PATH }}
          FTP_PROTOCOL: ${{ secrets.FTP_PROTOCOL }}
          FTP_PORT: ${{ secrets.FTP_PORT }}
          FTP_PATH_SUFFIX: ${{ vars.FTP_PATH_SUFFIX }}
          CHANNEL: ${{ needs.guard.outputs.channel }}
        run: |
          set -euo pipefail
          set -x

          ZIP="${{ steps.build.outputs.zip_name }}"

          : "${FTP_HOST:?Missing secret FTP_HOST}"
          : "${FTP_USER:?Missing secret FTP_USER}"
          : "${FTP_KEY:?Missing secret FTP_KEY}"
          : "${FTP_PATH:?Missing secret FTP_PATH}"

          PROTOCOL="${FTP_PROTOCOL:-sftp}"
          if [ "${PROTOCOL}" != "sftp" ]; then
            echo "ERROR: Only SFTP permitted" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          PORT="${FTP_PORT:-}"
          if [ -n "${PORT}" ]; then
            HOSTPORT="${FTP_HOST}:${PORT}"
          else
            HOSTPORT="${FTP_HOST}"
          fi

          SUFFIX="${FTP_PATH_SUFFIX:-}"
          if [ -n "${SUFFIX}" ]; then
            REMOTE_PATH="${FTP_PATH%/}/${SUFFIX%/}/${CHANNEL}"
          else
            REMOTE_PATH="${FTP_PATH%/}/${CHANNEL}"
          fi

          echo "SFTP target: sftp://${HOSTPORT}${REMOTE_PATH}" >> "${GITHUB_STEP_SUMMARY}"

          sudo apt-get update -y
          sudo apt-get install -y lftp openssh-client

          mkdir -p ~/.ssh
          echo "${FTP_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "${FTP_HOST}" >> ~/.ssh/known_hosts

          lftp -d -e "set sftp:auto-confirm yes; set cmd:trace yes; set net:timeout 30; set net:max-retries 3; set net:reconnect-interval-base 5; open -u '${FTP_USER}', sftp://${HOSTPORT}; pwd; ls; mkdir -p '${REMOTE_PATH}'; cd '${REMOTE_PATH}'; pwd; put -E 'dist/${ZIP}'; ls; bye"

      - name: Create Git tag for release
        id: tag
        run: |
          set -euo pipefail

          VERSION="${{ needs.guard.outputs.version }}"
          MODE="${{ needs.guard.outputs.release_mode }}"

          if [ "${MODE}" = "prerelease" ]; then
            TAG="v${VERSION}-rc"
          else
            TAG="v${VERSION}"
          fi

          git fetch --tags
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            echo "Tag ${TAG} already exists" >> "${GITHUB_STEP_SUMMARY}"
          else
            git tag -a "${TAG}" -m "${MODE} ${VERSION}"
            git push origin "refs/tags/${TAG}"
          fi

          echo "tag=${TAG}" >> "${GITHUB_OUTPUT}"

      - name: Generate release notes from CHANGELOG.md
        run: |
          set -euo pipefail

          VERSION="${{ needs.guard.outputs.version }}"
          ZIP_ASSET="${{ steps.build.outputs.zip_name }}"

          awk "/^## \[${VERSION}\]/{flag=1;next}/^## \[/{flag=0}flag" CHANGELOG.md > RELEASE_NOTES.md || true

          if [ ! -s RELEASE_NOTES.md ]; then
            echo "ERROR: Release notes extraction failed for ${VERSION}" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          {
            echo ""
            echo "Assets:"
            echo "- ${ZIP_ASSET}"
          } >> RELEASE_NOTES.md

      - name: Create GitHub release and attach ZIP
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: ${{ needs.guard.outputs.release_mode }} ${{ needs.guard.outputs.version }}
          prerelease: ${{ needs.guard.outputs.release_mode == 'prerelease' }}
          body_path: RELEASE_NOTES.md
          files: |
            dist/*.zip

      - name: Attest build provenance
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: |
            dist/*.zip

      - name: Publish JSON report to job summary
        run: |
          set -euo pipefail

          REPO_FULL="${{ github.repository }}"
          VERSION="${{ needs.guard.outputs.version }}"
          BRANCH="${{ needs.guard.outputs.promoted_branch }}"
          TAG="${{ steps.tag.outputs.tag }}"
          ZIP_NAME="${{ steps.build.outputs.zip_name }}"
          CHANNEL="${{ needs.guard.outputs.channel }}"
          MODE="${{ needs.guard.outputs.release_mode }}"
          OVERRIDE="${{ needs.guard.outputs.override }}"

          echo "### Release report (JSON)" >> "${GITHUB_STEP_SUMMARY}"
          echo "```json" >> "${GITHUB_STEP_SUMMARY}"
          echo "{\"repository\":\"${REPO_FULL}\",\"version\":\"${VERSION}\",\"branch\":\"${BRANCH}\",\"tag\":\"${TAG}\",\"mode\":\"${MODE}\",\"channel\":\"${CHANNEL}\",\"override\":\"${OVERRIDE}\",\"zip\":\"${ZIP_NAME}\"}" >> "${GITHUB_STEP_SUMMARY}"
          echo "```" >> "${GITHUB_STEP_SUMMARY}"

  push_version_to_main:
    name: 04 Promote version branch to main (stable only, keep version branch)
    runs-on: ubuntu-latest
    needs:
      - guard
      - build_and_release

    if: ${{ github.event_name == 'workflow_dispatch' && needs.guard.outputs.release_mode == 'stable' }}

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Configure Git identity
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global --add safe.directory "${GITHUB_WORKSPACE}"

      - name: Create PR from version branch to main
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          VERSION="${{ needs.guard.outputs.version }}"
          HEAD="${{ needs.guard.outputs.promoted_branch }}"

          gh pr create \
            --base main \
            --head "${HEAD}" \
            --title "Release ${VERSION} to main" \
            --body "Automated PR created by release pipeline. Version branch is retained by policy." \
            || true

      - name: Attempt to merge PR (best-effort)
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          HEAD="${{ needs.guard.outputs.promoted_branch }}"
          PR_NUMBER="$(gh pr list --head "${HEAD}" --base main --json number --jq '.[0].number' || true)"

          if [ -z "${PR_NUMBER}" ] || [ "${PR_NUMBER}" = "null" ]; then
            echo "ERROR: PR not found for head ${HEAD}" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          gh pr merge "${PR_NUMBER}" --merge --delete-branch=false \
            || echo "PR merge blocked by branch protection or policy" >> "${GITHUB_STEP_SUMMARY}"

          {
            echo "### Main branch promotion"
            echo "```json"
            echo "{\"head\":\"${HEAD}\",\"pr\":${PR_NUMBER}}"
            echo "```"
          } >> "${GITHUB_STEP_SUMMARY}"

  release_event_report:
    name: 99 Release event report (GitHub UI created release)
    runs-on: ubuntu-latest
    needs: guard

    if: ${{ github.event_name == 'release' }}

    permissions:
      contents: read

    steps:
      - name: Checkout tag
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}
          fetch-depth: 0

      - name: Publish JSON report to job summary
        run: |
          set -euo pipefail

          VERSION="${{ needs.guard.outputs.version }}"
          TAG="${{ github.ref_name }}"

          echo "### Release event report (JSON)" >> "${GITHUB_STEP_SUMMARY}"
          echo "```json" >> "${GITHUB_STEP_SUMMARY}"
          echo "{\"version\":\"${VERSION}\",\"tag\":\"${TAG}\",\"prerelease\":${{ github.event.release.prerelease }}}" >> "${GITHUB_STEP_SUMMARY}"
          echo "```" >> "${GITHUB_STEP_SUMMARY}"
