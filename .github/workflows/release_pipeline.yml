#
# Copyright (C) 2025 Moko Consulting <hello@mokoconsulting.tech>
#
# This file is part of a Moko Consulting project.
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# FILE INFORMATION
# DEFGROUP: GitHub.Workflow
# INGROUP: MokoStandards.Release
# REPO: https://github.com/mokoconsulting-tech/MokoStandards
# PATH: /.github/workflows/release_pipeline.yml
# VERSION: 01.01.00
# BRIEF: Enterprise release pipeline enforcing dev to rc to version to main. Creates prerelease when rc is created. Creates full release when version is created, and pushes version to main while retaining the version branch.
# NOTE: Key controls: strict branch gating, mandatory source branch deletion after promotion, least privilege permissions, key-only SFTP, ZIP-only distribution, overwrite enabled, no checksum generation.
#
name: Release Pipeline (dev to rc to version to main)

on:
  workflow_dispatch:
  release:
    types:
      - created
      - prereleased
      - published

concurrency:
  group: release-pipeline-${{ github.ref_name }}
  cancel-in-progress: false

defaults:
  run:
    shell: bash

permissions:
  contents: read

jobs:
  guard:
    name: 00 Guard and derive promotion metadata
    runs-on: ubuntu-latest

    outputs:
      version: ${{ steps.meta.outputs.version }}
      source_branch: ${{ steps.meta.outputs.source_branch }}
      source_prefix: ${{ steps.meta.outputs.source_prefix }}
      target_branch: ${{ steps.meta.outputs.target_branch }}
      promoted_branch: ${{ steps.meta.outputs.promoted_branch }}
      today_utc: ${{ steps.meta.outputs.today_utc }}
      channel: ${{ steps.meta.outputs.channel }}
      release_mode: ${{ steps.meta.outputs.release_mode }}

    steps:
      - name: Validate trigger and extract metadata
        id: meta
        run: |
          set -euo pipefail

          EVENT_NAME="${GITHUB_EVENT_NAME}"
          REF_NAME="${GITHUB_REF_NAME}"

          VERSION=""
          SOURCE_BRANCH=""
          SOURCE_PREFIX=""
          TARGET_BRANCH=""
          PROMOTED_BRANCH=""
          CHANNEL=""
          RELEASE_MODE="none"

          if [ "${EVENT_NAME}" = "workflow_dispatch" ]; then
            echo "${REF_NAME}" | grep -E '^(dev|rc)/[0-9]+[.][0-9]+[.][0-9]+$'

            SOURCE_BRANCH="${REF_NAME}"
            SOURCE_PREFIX="${REF_NAME%%/*}"
            VERSION="${REF_NAME#*/}"

            if [ "${SOURCE_PREFIX}" = "dev" ]; then
              # dev -> rc, then prerelease
              TARGET_BRANCH="rc/${VERSION}"
              PROMOTED_BRANCH="rc/${VERSION}"
              CHANNEL="rc"
              RELEASE_MODE="prerelease"
            else
              # rc -> version, then full release + push to main
              TARGET_BRANCH="version/${VERSION}"
              PROMOTED_BRANCH="version/${VERSION}"
              CHANNEL="stable"
              RELEASE_MODE="stable"
            fi

          elif [ "${EVENT_NAME}" = "release" ]; then
            TAG_NAME="${REF_NAME}"
            VERSION="${TAG_NAME#v}"
            echo "${VERSION}" | grep -E '^[0-9]+[.][0-9]+[.][0-9]+$'

            if [ "${{ github.event.release.prerelease }}" = "true" ]; then
              CHANNEL="rc"
              RELEASE_MODE="prerelease"
            else
              CHANNEL="stable"
              RELEASE_MODE="stable"
            fi

          else
            echo "ERROR: Unsupported trigger ${EVENT_NAME}" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          TODAY_UTC="$(date -u +%Y-%m-%d)"

          echo "version=${VERSION}" >> "${GITHUB_OUTPUT}"
          echo "source_branch=${SOURCE_BRANCH}" >> "${GITHUB_OUTPUT}"
          echo "source_prefix=${SOURCE_PREFIX}" >> "${GITHUB_OUTPUT}"
          echo "target_branch=${TARGET_BRANCH}" >> "${GITHUB_OUTPUT}"
          echo "promoted_branch=${PROMOTED_BRANCH}" >> "${GITHUB_OUTPUT}"
          echo "today_utc=${TODAY_UTC}" >> "${GITHUB_OUTPUT}"
          echo "channel=${CHANNEL}" >> "${GITHUB_OUTPUT}"
          echo "release_mode=${RELEASE_MODE}" >> "${GITHUB_OUTPUT}"

          {
            echo "### Guard report"
            echo "```json"
            echo "{"
            echo "  \"event\": \"${EVENT_NAME}\","
            echo "  \"ref\": \"${REF_NAME}\","
            echo "  \"version\": \"${VERSION}\","
            echo "  \"source_branch\": \"${SOURCE_BRANCH}\","
            echo "  \"target_branch\": \"${TARGET_BRANCH}\","
            echo "  \"promoted_branch\": \"${PROMOTED_BRANCH}\","
            echo "  \"channel\": \"${CHANNEL}\","
            echo "  \"release_mode\": \"${RELEASE_MODE}\","
            echo "  \"today_utc\": \"${TODAY_UTC}\""
            echo "}"
            echo "```"
          } >> "${GITHUB_STEP_SUMMARY}"

  promote_branch:
    name: 01 Promote branch and delete source
    runs-on: ubuntu-latest
    needs: guard

    if: ${{ github.event_name == 'workflow_dispatch' }}

    permissions:
      contents: write

    steps:
      - name: Checkout source branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.guard.outputs.source_branch }}
          fetch-depth: 0

      - name: Configure Git identity
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global --add safe.directory "${GITHUB_WORKSPACE}"

      - name: Enforce promotion preconditions
        run: |
          set -euo pipefail

          SRC="${{ needs.guard.outputs.source_branch }}"
          DST="${{ needs.guard.outputs.target_branch }}"

          git fetch origin --prune

          if [ -z "${SRC}" ] || [ -z "${DST}" ]; then
            echo "ERROR: guard did not emit SRC or DST" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          if ! git show-ref --verify --quiet "refs/remotes/origin/${SRC}"; then
            echo "ERROR: origin/${SRC} not found" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          if git show-ref --verify --quiet "refs/remotes/origin/${DST}"; then
            echo "ERROR: origin/${DST} already exists" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

      - name: Promote and delete source
        run: |
          set -euo pipefail

          SRC="${{ needs.guard.outputs.source_branch }}"
          DST="${{ needs.guard.outputs.target_branch }}"

          git checkout -B "${DST}" "origin/${SRC}"
          git push origin "${DST}"
          git push origin --delete "${SRC}"

          {
            echo "### Promotion report"
            echo "```json"
            echo "{"
            echo "  \"promoted\": \"${SRC} -> ${DST}\","
            echo "  \"deleted\": \"${SRC}\""
            echo "}"
            echo "```"
          } >> "${GITHUB_STEP_SUMMARY}"

  normalize_dates:
    name: 02 Normalize dates on promoted branch
    runs-on: ubuntu-latest
    needs:
      - guard
      - promote_branch

    if: ${{ github.event_name == 'workflow_dispatch' }}

    permissions:
      contents: write

    steps:
      - name: Checkout promoted branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.guard.outputs.promoted_branch }}
          fetch-depth: 0

      - name: Configure Git identity
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global --add safe.directory "${GITHUB_WORKSPACE}"

      - name: Validate repo prerequisites
        run: |
          set -euo pipefail
          test -d src || (echo "ERROR: src directory missing" && exit 1)
          test -f CHANGELOG.md || (echo "ERROR: CHANGELOG.md missing" && exit 1)

          VERSION="${{ needs.guard.outputs.version }}"

          if ! grep -F "## [${VERSION}] " CHANGELOG.md >/dev/null; then
            echo "ERROR: CHANGELOG.md missing heading for version [${VERSION}]" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

      - name: Normalize dates using repository script only
        run: |
          set -euo pipefail

          TODAY="${{ needs.guard.outputs.today_utc }}"
          VERSION="${{ needs.guard.outputs.version }}"

          if [ ! -f scripts/update_dates.sh ]; then
            echo "ERROR: scripts/update_dates.sh is required for enterprise releases" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          chmod +x scripts/update_dates.sh
          scripts/update_dates.sh "${TODAY}" "${VERSION}"

      - name: Commit and push date updates
        run: |
          set -euo pipefail

          if git diff --quiet; then
            echo "No date changes detected" >> "${GITHUB_STEP_SUMMARY}"
            exit 0
          fi

          git add -A
          git commit -m "chore(release): normalize dates for ${{ needs.guard.outputs.version }}"
          git push origin "HEAD:${{ needs.guard.outputs.promoted_branch }}"

  build_and_release:
    name: 03 Build ZIP, upload to SFTP, create GitHub release
    runs-on: ubuntu-latest
    needs:
      - guard
      - normalize_dates

    if: ${{ github.event_name == 'workflow_dispatch' }}

    permissions:
      contents: write
      id-token: write
      attestations: write

    steps:
      - name: Checkout promoted branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.guard.outputs.promoted_branch }}
          fetch-depth: 0

      - name: Configure Git identity
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global --add safe.directory "${GITHUB_WORKSPACE}"

      - name: Build Joomla compliant ZIP
        id: build
        run: |
          set -euo pipefail

          VERSION="${{ needs.guard.outputs.version }}"
          REPO="${{ github.event.repository.name }}"
          CHANNEL="${{ needs.guard.outputs.channel }}"

          test -d src || (echo "ERROR: src directory missing" && exit 1)

          mkdir -p dist

          ROOT="src"
          TOP_DIRS="$(find src -mindepth 1 -maxdepth 1 -type d | wc -l | tr -d ' ')"
          if [ "${TOP_DIRS}" = "1" ]; then
            ROOT="$(find src -mindepth 1 -maxdepth 1 -type d -print -quit)"
          fi

          MANIFEST=""
          if [ -f "${ROOT}/templateDetails.xml" ]; then
            MANIFEST="${ROOT}/templateDetails.xml"
          elif [ -f "src/templates/templateDetails.xml" ]; then
            MANIFEST="src/templates/templateDetails.xml"
          elif find "src/templates" -mindepth 2 -maxdepth 2 -name "templateDetails.xml" -type f | head -n 1 | grep -q .; then
            MANIFEST="$(find "src/templates" -mindepth 2 -maxdepth 2 -name "templateDetails.xml" -type f | head -n 1)"
          else
            CANDIDATE="$(find "${ROOT}" -maxdepth 1 -type f -name "*.xml" | head -n 1 || true)"
            if [ -n "${CANDIDATE}" ]; then
              MANIFEST="${CANDIDATE}"
            fi
          fi

          if [ -z "${MANIFEST}" ]; then
            echo "ERROR: No Joomla manifest XML found" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          EXT_TYPE="$(grep -o 'type=\"[^\"]*\"' "${MANIFEST}" | head -n 1 | cut -d '\"' -f2)"
          if [ -z "${EXT_TYPE}" ]; then
            EXT_TYPE="unknown"
          fi

          MANIFEST_DIR="$(dirname "${MANIFEST}")"
          if [ "${EXT_TYPE}" = "template" ] && [ "${MANIFEST_DIR}" != "${ROOT}" ]; then
            ROOT="${MANIFEST_DIR}"
          fi

          ZIP="${REPO}-${VERSION}-${CHANNEL}.zip"

          (cd "${ROOT}" && zip -r -X "../dist/${ZIP}" . \
            -x "**/.git/**" \
            -x "**/.github/**" \
            -x "**/.DS_Store" \
            -x "**/__MACOSX/**")

          echo "zip_name=${ZIP}" >> "${GITHUB_OUTPUT}"
          echo "root=${ROOT}" >> "${GITHUB_OUTPUT}"
          echo "manifest=${MANIFEST}" >> "${GITHUB_OUTPUT}"
          echo "ext_type=${EXT_TYPE}" >> "${GITHUB_OUTPUT}"

      - name: Upload ZIP to SFTP (key-only, overwrite)
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USER }}
          FTP_KEY: ${{ secrets.FTP_KEY }}
          FTP_PATH: ${{ secrets.FTP_PATH }}
          FTP_PROTOCOL: ${{ secrets.FTP_PROTOCOL }}
          FTP_PORT: ${{ secrets.FTP_PORT }}
          FTP_PATH_SUFFIX: ${{ vars.FTP_PATH_SUFFIX }}
          CHANNEL: ${{ needs.guard.outputs.channel }}
        run: |
          set -euo pipefail

          ZIP="${{ steps.build.outputs.zip_name }}"

          : "${FTP_HOST:?Missing secret FTP_HOST}"
          : "${FTP_USER:?Missing secret FTP_USER}"
          : "${FTP_KEY:?Missing secret FTP_KEY}"
          : "${FTP_PATH:?Missing secret FTP_PATH}"

          PROTOCOL="${FTP_PROTOCOL:-sftp}"
          if [ "${PROTOCOL}" != "sftp" ]; then
            echo "ERROR: Only SFTP permitted" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          PORT="${FTP_PORT:-}"
          if [ -n "${PORT}" ]; then
            HOSTPORT="${FTP_HOST}:${PORT}"
          else
            HOSTPORT="${FTP_HOST}"
          fi

          SUFFIX="${FTP_PATH_SUFFIX:-}"
          if [ -n "${SUFFIX}" ]; then
            REMOTE_PATH="${FTP_PATH%/}/${SUFFIX%/}/${CHANNEL}"
          else
            REMOTE_PATH="${FTP_PATH%/}/${CHANNEL}"
          fi

          sudo apt-get update -y
          sudo apt-get install -y lftp openssh-client

          mkdir -p ~/.ssh
          echo "${FTP_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "${FTP_HOST}" >> ~/.ssh/known_hosts

          lftp -e "set sftp:auto-confirm yes; open -u '${FTP_USER}', sftp://${HOSTPORT}; mkdir -p '${REMOTE_PATH}'; cd '${REMOTE_PATH}'; put -E 'dist/${ZIP}'; ls; bye"

      - name: Create Git tag for release
        id: tag
        run: |
          set -euo pipefail

          VERSION="${{ needs.guard.outputs.version }}"
          MODE="${{ needs.guard.outputs.release_mode }}"

          if [ "${MODE}" = "prerelease" ]; then
            TAG="v${VERSION}-rc"
          else
            TAG="v${VERSION}"
          fi

          git fetch --tags
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            echo "Tag ${TAG} already exists" >> "${GITHUB_STEP_SUMMARY}"
          else
            git tag -a "${TAG}" -m "${MODE} ${VERSION}"
            git push origin "refs/tags/${TAG}"
          fi

          echo "tag=${TAG}" >> "${GITHUB_OUTPUT}"

      - name: Generate release notes from CHANGELOG.md
        id: notes
        run: |
          set -euo pipefail

          VERSION="${{ needs.guard.outputs.version }}"
          ZIP_ASSET="${{ steps.build.outputs.zip_name }}"

          awk "/^## \[${VERSION}\]/{flag=1;next}/^## \[/ {flag=0}flag" CHANGELOG.md > RELEASE_NOTES.md || true

          if [ ! -s RELEASE_NOTES.md ]; then
            echo "ERROR: Release notes extraction failed for ${VERSION}" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          {
            echo ""
            echo "Assets:"
            echo "- ${ZIP_ASSET}"
          } >> RELEASE_NOTES.md

      - name: Create GitHub release and attach ZIP
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: ${{ needs.guard.outputs.release_mode }} ${{ needs.guard.outputs.version }}
          prerelease: ${{ needs.guard.outputs.release_mode == 'prerelease' }}
          body_path: RELEASE_NOTES.md
          files: |
            dist/*.zip

      - name: Attest build provenance
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: |
            dist/*.zip

      - name: Publish JSON report to job summary
        run: |
          set -euo pipefail

          REPO_FULL="${{ github.repository }}"
          VERSION="${{ needs.guard.outputs.version }}"
          BRANCH="${{ needs.guard.outputs.promoted_branch }}"
          TAG="${{ steps.tag.outputs.tag }}"
          ZIP_NAME="${{ steps.build.outputs.zip_name }}"
          CHANNEL="${{ needs.guard.outputs.channel }}"
          MODE="${{ needs.guard.outputs.release_mode }}"

          echo "### Release report (JSON)" >> "${GITHUB_STEP_SUMMARY}"
          echo "```json" >> "${GITHUB_STEP_SUMMARY}"
          echo "{\"repository\":\"${REPO_FULL}\",\"version\":\"${VERSION}\",\"branch\":\"${BRANCH}\",\"tag\":\"${TAG}\",\"mode\":\"${MODE}\",\"channel\":\"${CHANNEL}\",\"zip\":\"${ZIP_NAME}\",\"sha\":null}" >> "${GITHUB_STEP_SUMMARY}"
          echo "```" >> "${GITHUB_STEP_SUMMARY}"

  push_version_to_main:
    name: 04 Push version to main (stable only, keep version branch)
    runs-on: ubuntu-latest
    needs:
      - guard
      - build_and_release

    if: ${{ github.event_name == 'workflow_dispatch' && needs.guard.outputs.release_mode == 'stable' }}

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Configure Git identity
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global --add safe.directory "${GITHUB_WORKSPACE}"

      - name: Create PR from version branch to main
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          VERSION="${{ needs.guard.outputs.version }}"
          HEAD="${{ needs.guard.outputs.promoted_branch }}"
          TITLE="Release ${VERSION} to main"

          gh pr create \
            --base main \
            --head "${HEAD}" \
            --title "${TITLE}" \
            --body "Automated PR created by release pipeline. Version branch is retained by policy." \
            || true

      - name: Attempt to merge PR (best-effort)
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          VERSION="${{ needs.guard.outputs.version }}"
          HEAD="${{ needs.guard.outputs.promoted_branch }}"

          PR_NUMBER="$(gh pr list --head "${HEAD}" --base main --json number --jq '.[0].number' || true)"

          if [ -z "${PR_NUMBER}" ] || [ "${PR_NUMBER}" = "null" ]; then
            echo "ERROR: PR not found for head ${HEAD}" >> "${GITHUB_STEP_SUMMARY}"
            exit 1
          fi

          # Enterprise-safe default: merge commit, no branch deletion.
          gh pr merge "${PR_NUMBER}" --merge --delete-branch=false \
            || echo "PR merge blocked by branch protection or policy" >> "${GITHUB_STEP_SUMMARY}"

          {
            echo "### Main branch promotion"
            echo "```json"
            echo "{\"version\":\"${VERSION}\",\"head\":\"${HEAD}\",\"pr\":${PR_NUMBER}}"
            echo "```"
          } >> "${GITHUB_STEP_SUMMARY}"

  release_event_report:
    name: 99 Release event report (GitHub UI created release)
    runs-on: ubuntu-latest
    needs: guard

    if: ${{ github.event_name == 'release' }}

    permissions:
      contents: read

    steps:
      - name: Checkout tag
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}
          fetch-depth: 0

      - name: Publish JSON report to job summary
        run: |
          set -euo pipefail

          VERSION="${{ needs.guard.outputs.version }}"
          TAG="${{ github.ref_name }}"

          echo "### Release event report (JSON)" >> "${GITHUB_STEP_SUMMARY}"
          echo "```json" >> "${GITHUB_STEP_SUMMARY}"
          echo "{\"version\":\"${VERSION}\",\"tag\":\"${TAG}\",\"prerelease\":${{ github.event.release.prerelease }}}" >> "${GITHUB_STEP_SUMMARY}"
          echo "```" >> "${GITHUB_STEP_SUMMARY}"
