name: Create version branch and bump versions

on:
  workflow_dispatch:
    inputs:
      new_version:
        description: "New version in format NN.NN.NN (example 01.03.00)"
        required: true
      base_branch:
        description: "Base branch to branch from"
        required: false
        default: "main"
      branch_prefix:
        description: "Prefix for the new version branch"
        required: false
        default: "version/"
      commit_changes:
        description: "Commit and push changes"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"

permissions:
  contents: write

jobs:
  version-bump:
    runs-on: ubuntu-latest

    env:
      NEW_VERSION: ${{ github.event.inputs.new_version }}
      BASE_BRANCH: ${{ github.event.inputs.base_branch }}
      BRANCH_PREFIX: ${{ github.event.inputs.branch_prefix }}
      COMMIT_CHANGES: ${{ github.event.inputs.commit_changes }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.BASE_BRANCH }}

      - name: Validate inputs
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Validation error at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          echo "[INFO] Inputs received:"
          echo "  NEW_VERSION=${NEW_VERSION}"
          echo "  BASE_BRANCH=${BASE_BRANCH}"
          echo "  BRANCH_PREFIX=${BRANCH_PREFIX}"
          echo "  COMMIT_CHANGES=${COMMIT_CHANGES}"

          [[ -n "${NEW_VERSION}" ]] || { echo "[ERROR] new_version missing" >&2; exit 2; }
          [[ "${NEW_VERSION}" =~ ^[0-9]{2}\.[0-9]{2}\.[0-9]{2}$ ]] || { echo "[ERROR] Invalid version format: ${NEW_VERSION}" >&2; exit 2; }

          git show-ref --verify --quiet "refs/remotes/origin/${BASE_BRANCH}" || {
            echo "[ERROR] Base branch does not exist on origin: ${BASE_BRANCH}" >&2
            echo "[INFO] Remote branches:"
            git branch -a
            exit 2
          }

          echo "[INFO] Input validation passed"

      - name: Configure git identity
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Git identity step failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          echo "[INFO] Git identity configured"

      - name: Create version branch
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Branch creation failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          BRANCH_NAME="${BRANCH_PREFIX}${NEW_VERSION}"
          echo "[INFO] Creating branch: ${BRANCH_NAME} from origin/${BASE_BRANCH}"

          git fetch --all --tags --prune

          if git ls-remote --exit-code --heads origin "${BRANCH_NAME}" >/dev/null 2>&1; then
            echo "[ERROR] Branch already exists on origin: ${BRANCH_NAME}" >&2
            exit 2
          fi

          git checkout -B "${BRANCH_NAME}" "origin/${BASE_BRANCH}"

      - name: Version bump diagnostics
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "[INFO] Runner diagnostics"
          echo "[INFO] pwd: $(pwd)"
          echo "[INFO] git rev-parse HEAD: $(git rev-parse HEAD)"
          echo "[INFO] python3: $(command -v python3 || true)"
          python3 --version || true
          echo "[INFO] Top-level files:"
          ls -la

      - name: Bump versions in headers and XML (very verbose)
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Version bump failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          python3 - <<'PY'
          import os
          import re
          from pathlib import Path
          from collections import defaultdict

          new_version = os.environ.get("NEW_VERSION", "").strip()
          if not new_version:
            raise SystemExit("[FATAL] NEW_VERSION env var missing")

          root = Path(".").resolve()
          print(f"[INFO] Repo root: {root}")

          # Match any VERSION line, regardless of what is currently there.
          header_re = re.compile(r"(?m)^(\s*VERSION\s*:\s*)(\S+)(\s*)$")

          # Match any <version>value</version> tag, value can be any non-tag text.
          xml_re = re.compile(r"(?is)(<version\s*>)([^<]*?)(</version\s*>)")

          skip_ext = {".json", ".png", ".jpg", ".jpeg", ".gif", ".svg", ".ico", ".pdf", ".zip", ".7z", ".tar", ".gz", ".woff", ".woff2", ".ttf", ".otf", ".mp3", ".mp4"}
          skip_dirs = {".git", "node_modules", "vendor", ".venv", "dist", "build"}

          counters = defaultdict(int)
          updated = []

          def should_skip(p: Path) -> bool:
            if p.suffix.lower() in skip_ext:
              counters["skipped_by_ext"] += 1
              return True
            parts = {x.lower() for x in p.parts}
            if any(d in parts for d in skip_dirs):
              counters["skipped_by_dir"] += 1
              return True
            return False

          for p in root.rglob("*"):
            if not p.is_file():
              continue
            if should_skip(p):
              continue

            try:
              text = p.read_text(encoding="utf-8")
            except UnicodeDecodeError:
              counters["skipped_non_utf8"] += 1
              continue
            except Exception as e:
              counters["skipped_read_error"] += 1
              print(f"[WARN] Read error: {p} :: {e}")
              continue

            original = text

            # Replace any VERSION: token lines
            text, n1 = header_re.subn(r"\\1" + new_version + r"\\3", text)
            if n1:
              counters["header_replacements"] += n1

            # Replace XML <version> values only in .xml files
            if p.suffix.lower() == ".xml":
              text2, n2 = xml_re.subn(r"\\1" + new_version + r"\\3", text)
              text = text2
              if n2:
                counters["xml_replacements"] += n2

            if text != original:
              try:
                p.write_text(text, encoding="utf-8")
                updated.append(str(p))
              except Exception as e:
                raise SystemExit(f"[FATAL] Write failed: {p} :: {e}")

          print("[INFO] Scan summary")
          for k in sorted(counters.keys()):
            print(f"  {k}: {counters[k]}")

          print(f"[INFO] Updated files: {len(updated)}")
          for f in updated[:200]:
            print(f"  [UPDATED] {f}")
          if len(updated) > 200:
            print(f"  [INFO] (truncated) +{len(updated) - 200} more")

          if not updated:
            print("[DIAG] No files changed. Common causes:")
            print("  - Files do not contain 'VERSION:' lines")
            print("  - XML manifests do not contain <version> tags")
            print("  - Files are outside the checked-out workspace")
            raise SystemExit(1)
          PY

      - name: Show git status
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] git status failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR
          git status --porcelain=v1

      - name: Commit changes
        if: ${{ env.COMMIT_CHANGES == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Commit failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          if [[ -z "$(git status --porcelain=v1)" ]]; then
            echo "[INFO] No changes detected. Skipping commit and push."
            exit 0
          fi

          git add -A
          git commit -m "chore(release): bump version to ${NEW_VERSION}"

      - name: Push branch
        if: ${{ env.COMMIT_CHANGES == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Push failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          BRANCH_NAME="${BRANCH_PREFIX}${NEW_VERSION}"
          git push --set-upstream origin "${BRANCH_NAME}"

      - name: Output branch name
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "[INFO] Created branch: ${BRANCH_PREFIX}${NEW_VERSION}"
