name: Create version branch and bump versions
on:
  workflow_dispatch:
    inputs:
      new_version:
        description: "New version in format NN.NN.NN (example 03.01.00)"
        required: true
      base_branch:
        description: "Base branch to branch from"
        required: false
        default: "main"
      branch_prefix:
        description: "Prefix for the new version branch"
        required: false
        default: "version/"
      commit_changes:
        description: "Commit and push changes"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"

permissions:
  contents: write

jobs:
  version-bump:
    runs-on: ubuntu-latest

    env:
      NEW_VERSION: ${{ github.event.inputs.new_version }}
      BASE_BRANCH: ${{ github.event.inputs.base_branch }}
      BRANCH_PREFIX: ${{ github.event.inputs.branch_prefix }}
      COMMIT_CHANGES: ${{ github.event.inputs.commit_changes }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.BASE_BRANCH }}

      - name: Validate inputs
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Validation error at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          echo "[INFO] Inputs received:"
          echo "  NEW_VERSION=${NEW_VERSION}"
          echo "  BASE_BRANCH=${BASE_BRANCH}"
          echo "  BRANCH_PREFIX=${BRANCH_PREFIX}"
          echo "  COMMIT_CHANGES=${COMMIT_CHANGES}"

          [[ -n "${NEW_VERSION}" ]] || { echo "[ERROR] new_version missing" >&2; exit 2; }
          [[ "${NEW_VERSION}" =~ ^[0-9]{2}\.[0-9]{2}\.[0-9]{2}$ ]] || { echo "[ERROR] Invalid version format: ${NEW_VERSION}" >&2; exit 2; }

          git ls-remote --exit-code --heads origin "${BASE_BRANCH}" >/dev/null 2>&1 || {
            echo "[ERROR] Base branch does not exist on origin: ${BASE_BRANCH}" >&2
            echo "[INFO] Remote branches:"
            git ls-remote --heads origin | awk '{sub("refs/heads/","",$2); print $2}'
            exit 2
          }

          echo "[INFO] Input validation passed"

      - name: Configure git identity
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Git identity step failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          echo "[INFO] Git identity configured"

      - name: Create version branch
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Branch creation failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          BRANCH_NAME="${BRANCH_PREFIX}${NEW_VERSION}"
          echo "[INFO] Creating branch: ${BRANCH_NAME} from origin/${BASE_BRANCH}"

          git fetch --all --tags --prune

          if git ls-remote --exit-code --heads origin "${BRANCH_NAME}" >/dev/null 2>&1; then
            echo "[ERROR] Branch already exists on origin: ${BRANCH_NAME}" >&2
            exit 2
          fi

          git checkout -B "${BRANCH_NAME}" "origin/${BASE_BRANCH}"
          echo "BRANCH_NAME=${BRANCH_NAME}" >> "$GITHUB_ENV"

      - name: Ensure CHANGELOG.md has an H2 immediately after TODO block (repo creation)
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] CHANGELOG initialization failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          if [[ ! -f "CHANGELOG.md" ]]; then
            echo "[INFO] CHANGELOG.md missing. Pulling baseline from MokoDefaults/generic-git (main)."

            BASE_URL="https://raw.githubusercontent.com/mokoconsulting-tech/MokoDefaults/main/generic-git/CHANGELOG.md"

            if ! curl -fsSL "${BASE_URL}" -o CHANGELOG.md; then
              echo "[FATAL] Unable to fetch baseline CHANGELOG.md from: ${BASE_URL}" >&2
              echo "[FATAL] Validate repository visibility and path: MokoDefaults/main/generic-git/CHANGELOG.md" >&2
              exit 2
            fi

            echo "[INFO] Baseline CHANGELOG.md retrieved"
          fi

          python3 - <<'PY'
          import os
          import re
          from datetime import datetime, timezone
          from pathlib import Path

          new_version = os.environ.get('NEW_VERSION', '').strip() or '00.00.00'

          p = Path('CHANGELOG.md')
          text = p.read_text(encoding='utf-8', errors='replace').splitlines(True)

          todo_re = re.compile(r'^\s*##\s*(?:\[\s*TODO\s*\]|TODO)\s*$', re.IGNORECASE)
          h2_re = re.compile(r'^##\s+')
          bullet_re = re.compile(r'^\s*[-*+]\s+')
          blank_re = re.compile(r'^\s*$')

          idx = None
          for i, line in enumerate(text):
            clean = line.lstrip('\ufeff').rstrip('\n').rstrip('\r')
            if todo_re.match(clean):
              idx = i
              break

          if idx is None:
            print('[INFO] No TODO section found. No action taken.')
            raise SystemExit(0)

          j = idx + 1
          saw_bullet = False
          while j < len(text):
            line = text[j].rstrip('\n').rstrip('\r')
            if bullet_re.match(line):
              saw_bullet = True
              j += 1
              continue
            if blank_re.match(line):
              j += 1
              continue
            break

          if not saw_bullet:
            print('[INFO] TODO section missing bullet list, inserting placeholder bullet')
            text.insert(idx + 1, '- Placeholder TODO item\n')
            j = idx + 2

          # Do not duplicate the same version H2
          target_prefix = "## [" + new_version + "] "
          if any(line.strip().startswith(target_prefix) for line in text):
            print('[INFO] Version H2 already present. No action taken.')
            raise SystemExit(0)

          # Always insert the new version between TODO section and existing version entries
          stamp = datetime.now(timezone.utc).strftime('%Y-%m-%d')
          insert = chr(10) + "## [" + new_version + "] " + stamp + chr(10)
          print('[INFO] Inserting version H2 after TODO block')

          text.insert(j, insert)
          p.write_text(''.join(text), encoding='utf-8')
          PY

      - name: Preflight discovery (src and docs only)
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Preflight failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          TARGET_DIRS=(".")

          echo "[INFO] Scanning all directories except .github"
          HIT_VERSION=0
          HIT_XML=0

          COUNT=$(grep -RIn --exclude-dir=.git --exclude-dir=.github -i -E "VERSION[[:space:]]*:[[:space:]]*[0-9]{2}\.[0-9]{2}\.[0-9]{2}" . | wc -l || true)
          HIT_VERSION=${COUNT}
          echo "[INFO] VERSION: hits (repo-wide): ${HIT_VERSION}"

          COUNT=$(grep -RIn --exclude-dir=.git --exclude-dir=.github "<version" . | wc -l || true)
          HIT_XML=${COUNT}
          echo "[INFO] <version> hits (repo-wide): ${HIT_XML}"

      - name: Bump versions in headers and XML (src and docs only)
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Version bump failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          python3 - <<'PY'
          import os
          import re
          from pathlib import Path
          from collections import defaultdict

          new_version = os.environ.get("NEW_VERSION", "").strip()
          if not new_version:
            raise SystemExit("[FATAL] NEW_VERSION env var missing")

          root = Path(".").resolve()
          targets = [root]

          header_re = re.compile(r"(?im)(VERSION\s*:\s*)(\d{2}\.\d{2}\.\d{2})")
          xml_re = re.compile(r"(?is)(<version\s*>)([^<]*?)(</version\s*>)")

          skip_ext = {".json", ".png", ".jpg", ".jpeg", ".gif", ".svg", ".ico", ".pdf", ".zip", ".7z", ".tar", ".gz", ".woff", ".woff2", ".ttf", ".otf", ".mp3", ".mp4"}
          skip_dirs = {".git", ".github", "node_modules", "vendor", ".venv", "dist", "build"}

          counters = defaultdict(int)
          updated = []

          def should_skip(p: Path) -> bool:
            if p.suffix.lower() in skip_ext:
              counters["skipped_by_ext"] += 1
              return True
            parts = {x.lower() for x in p.parts}
            if any(d in parts for d in skip_dirs):
              counters["skipped_by_dir"] += 1
              return True
            return False

          existing_targets = [t for t in targets if t.exists() and t.is_dir()]
          if not existing_targets:
            raise SystemExit("[ERROR] Repository root not found")

          print(f"[INFO] Scanning repository (excluding: {', '.join(sorted(skip_dirs))})")

          for base in existing_targets:
            for p in base.rglob("*"):
              if not p.is_file():
                continue
              if should_skip(p):
                continue

              try:
                text = p.read_text(encoding="utf-8", errors="replace")
              except Exception as e:
                counters["skipped_read_error"] += 1
                print(f"[WARN] Read error: {p} :: {e}")
                continue

              original = text

              text, n1 = header_re.subn(lambda m: m.group(1) + new_version, text)
              if n1:
                counters["header_replacements"] += n1

              if p.suffix.lower() == ".xml":
                text2, n2 = xml_re.subn(lambda m: m.group(1) + new_version + m.group(3), text)
                text = text2
                if n2:
                  counters["xml_replacements"] += n2

              if text != original:
                try:
                  p.write_text(text, encoding="utf-8")
                  updated.append(str(p))
                except Exception as e:
                  raise SystemExit(f"[FATAL] Write failed: {p} :: {e}")

          print("[INFO] Scan summary")
          for k in sorted(counters.keys()):
            print(f"  {k}: {counters[k]}")

          print(f"[INFO] Updated files: {len(updated)}")
          for f in updated[:200]:
            print(f"  [UPDATED] {f}")
          if len(updated) > 200:
            print(f"  [INFO] (truncated) +{len(updated) - 200} more")

          if not updated:
            print("[ERROR] No files updated in repository (excluding .github)")
            print("[DIAG] Confirm these exist outside .github:")
            print("  - A line containing: VERSION: <value>")
            print("  - An XML tag: <version>...</version>")
            raise SystemExit(1)
          PY

      - name: Show git status
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] git status failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR
          git status --porcelain=v1

      - name: Commit changes
        if: ${{ env.COMMIT_CHANGES == 'true' }}
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Commit failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          git rev-parse --is-inside-work-tree >/dev/null 2>&1 || { echo "[ERROR] Not inside a git work tree" >&2; exit 2; }

          if [[ -z "$(git status --porcelain=v1)" ]]; then
            echo "[INFO] No changes detected. Skipping commit and push."
            exit 0
          fi

          echo "[INFO] Staging all changes except .github"
          git add -A -- . ":(exclude).github"

          git commit -m "chore(release): bump version to ${NEW_VERSION}"

      - name: Push branch
        shell: bash
        run: |
          set -Eeuo pipefail
          trap 'echo "[FATAL] Push failed at line $LINENO" >&2; echo "[FATAL] Last command: $BASH_COMMAND" >&2' ERR

          git push --set-upstream origin "${BRANCH_NAME}"

      - name: Output branch name
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "[INFO] Created branch: ${BRANCH_NAME}"
