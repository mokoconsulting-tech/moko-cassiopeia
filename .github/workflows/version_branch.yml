#
# Copyright (C) 2025 Moko Consulting <hello@mokoconsulting.tech>
#
# This file is part of a Moko Consulting project.
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# FILE INFORMATION
# DEFGROUP: GitHub.Workflow
# INGROUP: Versioning.Branching
# REPO: https://github.com/mokoconsulting-tech/MokoStandards
# PATH: /.github/workflows/version_branch.yml
# VERSION: 01.00.00
# BRIEF: Create a version branch and align versions across governed files
# NOTE: Enterprise gates: policy checks, collision defense, manifest targeting, audit summary, error summary

name: Create version branch and bump versions

on:
  workflow_dispatch:
    inputs:
      new_version:
        description: "New version in format NN.NN.NN (example 03.01.00)"
        required: true
      commit_changes:
        description: "Commit and push changes"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"

concurrency:
  group: ${{ github.workflow }}-${{ github.repository }}-${{ github.event.inputs.new_version }}
  cancel-in-progress: false

permissions:
  contents: write

defaults:
  run:
    shell: bash

jobs:
  version-bump:
    runs-on: ubuntu-latest

    env:
      NEW_VERSION: ${{ github.event.inputs.new_version }}
      BASE_BRANCH: ${{ github.ref_name }}
      BRANCH_PREFIX: dev/
      COMMIT_CHANGES: ${{ github.event.inputs.commit_changes }}
      ERROR_LOG: /tmp/version_branch_errors.log
      CI_HELPERS: /tmp/moko_ci_helpers.sh

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref_name }}

      - name: Init CI helpers
        run: |
          set -Eeuo pipefail

          : > "$ERROR_LOG"

          cat > "$CI_HELPERS" <<'SH'
          set -Eeuo pipefail

          moko_init() {
            local step_name="${1:-step}"

            export PS4='+ ['"${step_name}"':${BASH_SOURCE##*/}:${LINENO}] '
            set -x

            trap 'moko_on_err "$step_name" "$LINENO" "$BASH_COMMAND"' ERR
          }

          moko_on_err() {
            local step_name="$1"
            local line_no="$2"
            local last_cmd="$3"

            echo "[FATAL] ${step_name} failed at line ${line_no}" >&2
            echo "[FATAL] Last command: ${last_cmd}" >&2

            if [[ -n "${ERROR_LOG:-}" ]]; then
              echo "$(date -u +%Y-%m-%dT%H:%M:%SZ) | ${step_name} | line ${line_no} | ${last_cmd}" >> "$ERROR_LOG" || true
            fi
          }
          SH

          chmod 0755 "$CI_HELPERS"

      - name: Validate inputs
        run: |
          source "$CI_HELPERS"
          moko_init "Validate inputs"

          echo "[INFO] Inputs received:"
          echo "  NEW_VERSION=${NEW_VERSION}"
          echo "  BASE_BRANCH=${BASE_BRANCH}"
          echo "  BRANCH_PREFIX=${BRANCH_PREFIX}"
          echo "  COMMIT_CHANGES=${COMMIT_CHANGES}"

          [[ -n "${NEW_VERSION}" ]] || { echo "[ERROR] new_version missing" >&2; exit 2; }
          [[ "${NEW_VERSION}" =~ ^[0-9]{2}[.][0-9]{2}[.][0-9]{2}$ ]] || { echo "[ERROR] Invalid version format: ${NEW_VERSION}" >&2; exit 2; }

          git ls-remote --exit-code --heads origin "${BASE_BRANCH}" >/dev/null 2>&1 || {
            echo "[ERROR] Base branch does not exist on origin: ${BASE_BRANCH}" >&2
            echo "[INFO] Remote branches:" >&2
            git ls-remote --heads origin | awk '{sub("refs/heads/","",$2); print $2}' >&2
            exit 2
          }

          echo "[INFO] Input validation passed"

      - name: Enterprise policy gate (required files)
        run: |
          source "$CI_HELPERS"
          moko_init "Enterprise policy gate"

          required=(
            "LICENSE.md"
            "CONTRIBUTING.md"
            "CODE_OF_CONDUCT.md"
            "SECURITY.md"
            "GOVERNANCE.md"
            "CHANGELOG.md"
          )

          missing=0
          for f in "${required[@]}"; do
            if [[ ! -f "${f}" ]]; then
              echo "[ERROR] Missing required file: ${f}" >&2
              missing=1
              continue
            fi
            if [[ ! -s "${f}" ]]; then
              echo "[ERROR] Required file is empty: ${f}" >&2
              missing=1
              continue
            fi
          done

          if [[ "${missing}" -ne 0 ]]; then
            echo "[FATAL] Policy gate failed. Add missing governance artifacts before versioning." >&2
            exit 2
          fi

          if [[ -f ".github/CODEOWNERS" ]] && [[ ! -s ".github/CODEOWNERS" ]]; then
            echo "[ERROR] .github/CODEOWNERS exists but is empty" >&2
            exit 2
          fi

          echo "[INFO] Policy gate passed"

      - name: Configure git identity
        run: |
          source "$CI_HELPERS"
          moko_init "Configure git identity"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          echo "[INFO] Git identity configured"

      - name: Branch namespace collision defense
        run: |
          source "$CI_HELPERS"
          moko_init "Branch namespace collision defense"

          PREFIX_TOP="${BRANCH_PREFIX%%/*}"
          if git ls-remote --exit-code --heads origin "${PREFIX_TOP}" >/dev/null 2>&1; then
            echo "[ERROR] Branch namespace collision detected" >&2
            echo "[ERROR] A branch named '${PREFIX_TOP}' exists on origin, so '${BRANCH_PREFIX}<version>' cannot be created." >&2
            echo "[ERROR] Remediation options:" >&2
            echo "  - Change BRANCH_PREFIX to a non colliding namespace (example: release/dev/)" >&2
            echo "  - Rename the existing '${PREFIX_TOP}' branch (organizational policy permitting)" >&2
            exit 2
          fi

          echo "[INFO] No namespace collision detected for BRANCH_PREFIX=${BRANCH_PREFIX}"

      - name: Create and push version branch
        run: |
          source "$CI_HELPERS"
          moko_init "Create and push version branch"

          BRANCH_NAME="${BRANCH_PREFIX}${NEW_VERSION}"
          echo "[INFO] Creating branch: ${BRANCH_NAME} from origin/${BASE_BRANCH}"

          git fetch --all --tags --prune

          if git ls-remote --exit-code --heads origin "${BRANCH_NAME}" >/dev/null 2>&1; then
            echo "[ERROR] Branch already exists on origin: ${BRANCH_NAME}" >&2
            exit 2
          fi

          git checkout -B "${BRANCH_NAME}" "origin/${BASE_BRANCH}"
          echo "BRANCH_NAME=${BRANCH_NAME}" >> "$GITHUB_ENV"

          echo "[INFO] Pushing new branch to origin"
          git push --set-upstream origin "${BRANCH_NAME}"

      - name: Ensure CHANGELOG.md has a release entry and a VERSION line
        run: |
          source "$CI_HELPERS"
          moko_init "CHANGELOG governance"

          python3 - <<'PY'
          import os
          import re
          from datetime import datetime, timezone
          from pathlib import Path

          nl = chr(10)
          cr = chr(13)

          new_version = (os.environ.get('NEW_VERSION') or '').strip() or '00.00.00'

          p = Path('CHANGELOG.md')
          if not p.exists():
            raise SystemExit('[FATAL] CHANGELOG.md missing')

          text = p.read_text(encoding='utf-8', errors='replace').splitlines(True)

          todo_re = re.compile(r'^[ 	]*##[ 	]*(?:\[[ 	]*TODO[ 	]*\]|TODO)[ 	]*$', re.IGNORECASE)
          bullet_re = re.compile(r'^[ 	]*[-*+][ 	]+')
          blank_re = re.compile(r'^[ 	]*$')
          unreleased_re = re.compile(r'^[ 	]*##[ 	]*(?:\[[ 	]*UNRELEASED[ 	]*\]|UNRELEASED)[ 	]*$', re.IGNORECASE)

          idx = None
          for i, line in enumerate(text):
            clean = line.lstrip(chr(65279)).rstrip(nl).rstrip(cr)
            if todo_re.match(clean):
              idx = i
              break

          if idx is None:
            # Enterprise safe fallback: insert after first H1 '# Changelog' when TODO section is absent.
            h1_re = re.compile(r'^#\s+Changelog\s*$', re.IGNORECASE)
            h1_idx = None
            for i, line in enumerate(text):
              if h1_re.match(line.strip()):
                h1_idx = i
                break

            if h1_idx is None:
              print('[ERROR] CHANGELOG.md missing required H1: # Changelog')
              raise SystemExit(2)

            # Insert after H1 and any following blank lines
            j = h1_idx + 1
            while j < len(text) and blank_re.match(text[j].rstrip(nl).rstrip(cr)):
              j += 1

            # Mark idx as H1 position so later logic can compute insert point.
            idx = h1_idx
            # Skip TODO bullet enforcement when TODO does not exist.
            saw_bullet = True


          j = idx + 1
          saw_bullet = False
          while j < len(text):
            line = text[j].rstrip(nl).rstrip(cr)
            if bullet_re.match(line):
              saw_bullet = True
              j += 1
              continue
            if blank_re.match(line):
              j += 1
              continue
            break

          if not saw_bullet:
            text.insert(idx + 1, '- Placeholder TODO item' + nl)
            j = idx + 2

          stamp = datetime.now(timezone.utc).strftime('%Y-%m-%d')
          version_heading = '## [' + new_version + '] ' + stamp + nl

          target_prefix = '## [' + new_version + '] '
          if any(l.strip().startswith(target_prefix) for l in text):
            print('[INFO] Version H2 already present. No action taken.')
            raise SystemExit(0)

          unreleased_idx = None
          for i, line in enumerate(text):
            if unreleased_re.match(line.strip()):
              unreleased_idx = i
              break

          def ensure_version_line(at_index: int) -> None:
            k = at_index + 1
            while k < len(text) and blank_re.match(text[k].rstrip(nl).rstrip(cr)):
              k += 1
            if k >= len(text) or not text[k].lstrip().startswith('- VERSION:'):
              text.insert(at_index + 1, '- VERSION: ' + new_version + nl)
              text.insert(at_index + 2, '- Version bump' + nl)

          if unreleased_idx is not None:
            # Move all content under UNRELEASED into this release
            text[unreleased_idx] = version_heading

            k = unreleased_idx + 1
            moved = []
            while k < len(text):
              line = text[k]
              if line.lstrip().startswith('## '):
                break
              moved.append(line)
              k += 1

            # Ensure VERSION line exists at top of moved block
            if not any(l.lstrip().startswith('- VERSION:') for l in moved):
              moved.insert(0, '- VERSION: ' + new_version + nl)

            # Replace content with moved lines
            text[unreleased_idx + 1:k] = moved

            # Insert a fresh UNRELEASED section immediately after TODO block
            insert_unreleased = nl + '## [UNRELEASED]' + nl + '- Placeholder for next release' + nl + nl
            text.insert(j, insert_unreleased)

            p.write_text(''.join(text), encoding='utf-8')
            raise SystemExit(0)

          insert = (
            nl +
            '## [' + new_version + '] ' + stamp + nl +
            '- VERSION: ' + new_version + nl +
            '- Version bump' + nl
          )
          text.insert(j, insert)
          p.write_text(''.join(text), encoding='utf-8')
          PY

      - name: Preflight discovery (governed version markers outside .github)
        run: |
          source "$CI_HELPERS"
          moko_init "Preflight discovery"

          echo "[INFO] Scanning all directories except .github"

          COUNT=$(grep -RIn --exclude-dir=.git --exclude-dir=.github -i -E "VERSION[[:space:]]*:[[:space:]]*[0-9]{2}[.][0-9]{2}[.][0-9]{2}" . | wc -l || true)
          echo "[INFO] VERSION: hits (repo-wide): ${COUNT}"

          COUNT2=$(grep -RIn --exclude-dir=.git --exclude-dir=.github "<version" . | wc -l || true)
          echo "[INFO] <version> hits (repo-wide): ${COUNT2}"

          if [[ "${COUNT}" -eq 0 && "${COUNT2}" -eq 0 ]]; then
            echo "[ERROR] No VERSION: (NN.NN.NN) or <version> tags found outside .github" >&2
            exit 2
          fi

      - name: Bump versions and update manifest dates (targeted, excluding .github)
        run: |
          source "$CI_HELPERS"
          moko_init "Version bump"

          python3 - <<'PY'
          import json
          import os
          import re
          from pathlib import Path
          from collections import defaultdict
          from datetime import datetime, timezone

          new_version = (os.environ.get('NEW_VERSION') or '').strip()
          if not new_version:
            raise SystemExit('[FATAL] NEW_VERSION env var missing')

          stamp = datetime.now(timezone.utc).strftime('%Y-%m-%d')
          root = Path('.').resolve()

          header_re = re.compile(r'(?im)(VERSION[ 	]*:[ 	]*)([0-9]{2}[.][0-9]{2}[.][0-9]{2})')

          manifest_marker_re = re.compile(r'(?is)<extension\b')
          # Joomla update server feeds commonly use <updates> root
          updates_marker_re = re.compile(r'(?is)<updates\b|<update\b')
          xml_version_re = re.compile(r'(?is)(<version[ 	]*>)([^<]*?)(</version[ 	]*>)')
          xml_date_res = [
            re.compile(r'(?is)(<creationDate[ 	]*>)([^<]*?)(</creationDate[ 	]*>)'),
            re.compile(r'(?is)(<date[ 	]*>)([^<]*?)(</date[ 	]*>)'),
            re.compile(r'(?is)(<releaseDate[ 	]*>)([^<]*?)(</releaseDate[ 	]*>)'),
          ]

          skip_ext = {
            '.json', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico', '.pdf',
            '.zip', '.7z', '.tar', '.gz', '.woff', '.woff2', '.ttf', '.otf',
            '.mp3', '.mp4'
          }
          skip_dirs = {'.git', '.github', 'node_modules', 'vendor', '.venv', 'dist', 'build'}

          counters = defaultdict(int)
          updated = []
          updated_manifests = []

          def should_skip(p: Path) -> bool:
            if p.suffix.lower() in skip_ext:
              counters['skipped_by_ext'] += 1
              return True
            parts = {x.lower() for x in p.parts}
            if any(d in parts for d in skip_dirs):
              counters['skipped_by_dir'] += 1
              return True
            return False

          for p in root.rglob('*'):
            if not p.is_file():
              continue
            if should_skip(p):
              continue

            try:
              text = p.read_text(encoding='utf-8', errors='replace')
            except Exception:
              counters['skipped_read_error'] += 1
              continue

            original = text

            text, n1 = header_re.subn(lambda m: m.group(1) + new_version, text)
            if n1:
              counters['header_replacements'] += n1

            if p.suffix.lower() == '.xml':
              # Joomla manifest files
              if manifest_marker_re.search(text):
                text2, n2 = xml_version_re.subn(lambda m: m.group(1) + new_version + m.group(3), text)
                text = text2
                if n2:
                  counters['xml_version_replacements'] += n2

                for rx in xml_date_res:
                  text3, n3 = rx.subn(lambda m: m.group(1) + stamp + m.group(3), text)
                  text = text3
                  if n3:
                    counters['xml_date_replacements'] += n3

                if text != original:
                  updated_manifests.append(str(p))
              else:
                # Special case: update server feeds (updates.xml, update.xml, or any XML containing <updates>/<update>)
                if p.name.lower() in {'updates.xml', 'update.xml'} or updates_marker_re.search(text):
                  text2, n2 = xml_version_re.subn(lambda m: m.group(1) + new_version + m.group(3), text)
                  text = text2
                  if n2:
                    counters['xml_version_replacements'] += n2

                  for rx in xml_date_res:
                    text3, n3 = rx.subn(lambda m: m.group(1) + stamp + m.group(3), text)
                    text = text3
                    if n3:
                      counters['xml_date_replacements'] += n3

                  if text != original:
                    updated_manifests.append(str(p))
                else:
                  counters['xml_skipped_non_manifest'] += 1

            if text != original:
              p.write_text(text, encoding='utf-8')
              updated.append(str(p))

          report = {
            'new_version': new_version,
            'stamp_utc': stamp,
            'counters': dict(counters),
            'updated_files': updated,
            'updated_manifests': updated_manifests,
          }

          Path('.github').mkdir(parents=True, exist_ok=True)
          Path('.github/version-bump-report.json').write_text(json.dumps(report, indent=2), encoding='utf-8')

          print('[INFO] Scan summary')
          for k in sorted(counters.keys()):
            print('  ' + k + ': ' + str(counters[k]))

          print('[INFO] Updated files: ' + str(len(updated)))
          print('[INFO] Updated manifests: ' + str(len(updated_manifests)))

          if not updated:
            print('[INFO] No eligible files updated. Skipping version bump without failure.')
            raise SystemExit(0)
          PY

      - name: Post bump audit (updates.xml date only)
        run: |
          source "$CI_HELPERS"
          moko_init "Post bump audit (updates.xml date only)"

          python3 - <<'PY'
          import json
          import re
          from pathlib import Path

          report_path = Path('.github/version-bump-report.json')
          if not report_path.exists():
            print('[INFO] No bump report found. Skipping updates.xml audit.')
            raise SystemExit(0)

          report = json.loads(report_path.read_text(encoding='utf-8', errors='replace'))
          stamp = (report.get('stamp_utc') or '').strip()
          if not stamp:
            print('[INFO] No stamp_utc in bump report. Skipping updates.xml audit.')
            raise SystemExit(0)

          p = Path('updates.xml')
          if not p.exists():
            print('[INFO] updates.xml not present. Skipping updates.xml date audit.')
            raise SystemExit(0)

          text = p.read_text(encoding='utf-8', errors='replace')

          tags = ['creationDate', 'date', 'releaseDate']
          mismatches = []

          for t in tags:
            rx = re.compile(r'(?is)<' + re.escape(t) + r'\s*>([^<]*?)</' + re.escape(t) + r'\s*>')
            m = rx.search(text)
            if not m:
              continue
            current = (m.group(1) or '').strip()
            if current != stamp:
              mismatches.append('<' + t + '> ' + current + ' != ' + stamp)

          if mismatches:
            print('[ERROR] updates.xml date audit failed. Mismatches found:')
            for x in mismatches:
              print('  ' + x)
            raise SystemExit(2)

          print('[INFO] updates.xml date audit passed')
          PY

      - name: Change scope guard (block .github edits)
        run: |
          source "$CI_HELPERS"
          moko_init "Change scope guard"

          if [[ -z "$(git status --porcelain=v1)" ]]; then
            echo "[INFO] No changes detected. Scope guard skipped."
            exit 0
          fi

          echo "[INFO] Evaluating changed paths"
          git diff --name-only > /tmp/changed_paths.txt

          bad=0
          while IFS= read -r p; do
            if [[ "$p" == .github/* ]] && [[ "$p" != .github/version-bump-report.json ]]; then
              echo "[ERROR] .github change is not permitted by this workflow: $p" >&2
              bad=1
            fi
          done < /tmp/changed_paths.txt

          if [[ "$bad" -ne 0 ]]; then
            echo "[FATAL] Change scope guard failed. Workflow attempted to modify .github content." >&2
            echo "$(date -u +%Y-%m-%dT%H:%M:%SZ) | Change scope guard | attempted .github modifications" >> "$ERROR_LOG" || true
            exit 2
          fi

          echo "[INFO] Scope guard passed"

      - name: Publish audit trail to job summary
        if: always()
        run: |
          source "$CI_HELPERS"
          moko_init "Publish audit trail"

          echo "# Version branch run" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- Repository: $GITHUB_REPOSITORY" >> "$GITHUB_STEP_SUMMARY"
          echo "- Base branch: ${BASE_BRANCH}" >> "$GITHUB_STEP_SUMMARY"
          echo "- New branch: ${BRANCH_NAME:-}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Version: ${NEW_VERSION}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Commit changes: ${COMMIT_CHANGES}" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [[ -f ".github/version-bump-report.json" ]]; then
            echo "## Bump report" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "\`\`\`json" >> "$GITHUB_STEP_SUMMARY"
            head -c 12000 ".github/version-bump-report.json" >> "$GITHUB_STEP_SUMMARY" || true
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "\`\`\`" >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "## Error summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [[ -f "$ERROR_LOG" && -s "$ERROR_LOG" ]]; then
            echo "\`\`\`" >> "$GITHUB_STEP_SUMMARY"
            tail -n 200 "$ERROR_LOG" >> "$GITHUB_STEP_SUMMARY" || true
            echo "\`\`\`" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "No errors recorded." >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Show git status
        run: |
          source "$CI_HELPERS"
          moko_init "Show git status"

          git status --porcelain=v1

      - name: Commit changes
        id: commit
        if: ${{ env.COMMIT_CHANGES == 'true' }}
        run: |
          source "$CI_HELPERS"
          moko_init "Commit changes"

          git rev-parse --is-inside-work-tree >/dev/null 2>&1 || { echo "[ERROR] Not inside a git work tree" >&2; exit 2; }

          if [[ -z "$(git status --porcelain=v1)" ]]; then
            echo "[INFO] No changes detected. Skipping commit and push."
            echo "committed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "[INFO] Staging all changes except .github"
          git add -A -- . ":(exclude).github"

          git commit -m "chore(release): bump version to ${NEW_VERSION}"
          echo "committed=true" >> "$GITHUB_OUTPUT"

      - name: Push commits
        if: ${{ env.COMMIT_CHANGES == 'true' && steps.commit.outputs.committed == 'true' }}
        run: |
          source "$CI_HELPERS"
          moko_init "Push commits"

          git push

      - name: Output branch name
        if: always()
        run: |
          source "$CI_HELPERS"
          moko_init "Output branch name"

          echo "[INFO] Created branch: ${BRANCH_NAME:-}"
